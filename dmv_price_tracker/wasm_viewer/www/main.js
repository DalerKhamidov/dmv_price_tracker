import init, { load_and_render_map } from '../pkg/wasm_viewer.js';

async function run() {
    // 1. Initialize WASM
    await init();

    // 2. Get Mapbox Access Token (REPLACE THIS)
    // You MUST get your own token from mapbox.com
    const MAPBOX_ACCESS_TOKEN = 'YOUR_MAPBOX_ACCESS_TOKEN';
    if (MAPBOX_ACCESS_TOKEN === 'YOUR_MAPBOX_ACCESS_TOKEN') {
        document.getElementById('vis').innerHTML = 
            '<h2>Error: Please set YOUR_MAPBOX_ACCESS_TOKEN in main.js</h2>';
        return;
    }

    try {
        // 3. Call WASM function to get Vega-Lite spec
        const specJson = await load_and_render_map();
        const spec = JSON.parse(specJson);

        // 4. Inject Mapbox token into the spec
        // This is a workaround as Plotlars/Vega-Lite might not have a direct way
        // to pass the token via the spec config for Mapbox layers.
        // We will manually configure vega-embed to use it.

        console.log("Vega-Lite Spec:", spec);
        
        // 5. Render the chart with vegaEmbed
        // We pass the token to vegaEmbed, which it should use for map tiles.
        // Note: Plotlars generates a Vega spec, not Vega-Lite, so we embed directly.
        // If it were Vega-Lite, we'd use `vegaEmbed("#vis", spec, { ... })`
        
        // Since Plotlars outputs Vega, we must adjust.
        // Let's assume `load_and_render_map` returns a full VEGA spec.
        
        const runtime = vega.parse(spec);
        const view = new vega.View(runtime)
            .renderer('svg')  // 'svg' or 'canvas'
            .initialize('#vis')
            .hover();
            
        // Manually set Mapbox token for Vega
        // This is the correct way for Vega specs generated by Plotlars
        view.runAsync({ mapboxAccessToken: MAPBOX_ACCESS_TOKEN });

        console.log("Map rendered.");

    } catch (error) {
        console.error("Error loading or rendering map:", error);
        document.getElementById('vis').innerHTML = 
            `<pre>Error: ${error}</pre>`;
    }
}

run();